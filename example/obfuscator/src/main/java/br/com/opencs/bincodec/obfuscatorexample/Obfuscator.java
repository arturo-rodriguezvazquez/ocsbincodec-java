/*
 * Copyright (c) 2015, Open Communications Security
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of ocsbincodec-java nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package br.com.opencs.bincodec.obfuscatorexample;

import java.text.MessageFormat;
import java.util.Random;

import br.com.opencs.bincodec.ArrayAlphabet;
import br.com.opencs.bincodec.Base2NCodec;
import br.com.opencs.bincodec.random.RandomAlphabetGenerator;

public class Obfuscator {

	
	public static void main(String args[]){
		Random random = new Random();
		long seed = 123456;
		int rounds = 4;
		
		// This obfuscation example uses a Base32 coded with a custom alphabet
		// generated by the parameters seed and rounds. This is equivalent to
		// use the standard Base32 encoding and them cipher the result using
		// a substitution cipher. The data will remain obfuscated as long as
		// the encoding alphabet is not known.
		//
		// Notice that substitution ciphers are very weak for today's standard
		// and can be broken easily using brute force attacks. Even so, this
		// technique will prevent most regular users about how the information
		// is encoded.
		//
		// No matter what you do, no obuscation technique can be used as a 
		// way to protect sensitive data because it will eventually be broken
		// regardless of how complex it may be.
		
		// Create the data to be obfuscated
		byte src[] = new byte[32];
		random.nextBytes(src);
		
		// Obfuscation with seed and rounds. This scheme can be used on text QRCodes.
		System.out.println("Obfuscating...");
		char alphabet[] = RandomAlphabetGenerator.generateRandom(seed, rounds, RandomAlphabetGenerator.QRCODE_ALPHANUMERIC_NO_SPACE, 32);
		Base2NCodec encoder = new Base2NCodec(new ArrayAlphabet(alphabet));
		String encoded = encoder.encode(src);
		System.out.print(MessageFormat.format("The obfuscated data is ''{0}''.\n", new Object[] {encoded}));
		
		// Deobfuscation with the same seed and rounds
		System.out.println("Deobfuscating...");
		char decAlphabet[] = RandomAlphabetGenerator.generateRandom(seed, rounds, RandomAlphabetGenerator.QRCODE_ALPHANUMERIC_NO_SPACE, 32);
		Base2NCodec decoder = new Base2NCodec(new ArrayAlphabet(decAlphabet));
		byte dst[] = decoder.decode(encoded);
		
		// Check the result
		int count = 0;
		for (int i = 0; i < src.length; i++) {
			if (dst[i] != src[i]) {
				count++;
			}
		}
		if (count == 0) {
			System.out.println("Deobfuscation successfull.");
		} else {
			System.out.println("Deobfuscation failed.");
		}
	}
}
